1. DFS와 BFS https://www.acmicpc.net/problem/1260

   ```
   def dfs(graph, start_node):
       visited = []
       stack = [start_node]
   
       while stack:
           current = stack.pop()
           if current not in visited:
               visited.append(current)
               if current in graph:
                   temp = graph[current]
                   temp.sort(reverse=True)
                   stack.extend(temp)
       return ' '.join(map(str,visited))
       
   def bfs(graph, start_node):
       visited = []
       queue = [start_node]
   
       while queue:
           current = queue.pop(0)
           if current not in visited:
               visited.append(current)
               if current in graph:
                   temp = graph[current]
                   temp.sort()
                   queue.extend(temp)
   
       return ' '.join(map(str,visited))
   
   n,m,v = map(int, input().split())
   graph = {}
   for i in range(m):
       a,b = map(int, input().split())
       graph[a] = graph.get(a, []) + [b]
       graph[b] = graph.get(b, []) + [a]
   print(dfs(graph, v))
   print(bfs(graph, v))
   ```

2. 바이러스 https://www.acmicpc.net/problem/2606

   ```
   def dfs(graph, start_node):
       visited = []
       stack = [start_node]
   
       while stack:
           current = stack.pop()
           if current not in visited:
               visited.append(current)
               if current in graph:
                   temp = graph[current]
                   temp.sort(reverse=True)
                   stack.extend(temp)
       visited.remove(1)
       return len(visited)
   
   n = int(input())
   m = int(input())
   graph = {}
   for i in range(m):
       a,b = map(int, input().split())
       graph[a] = graph.get(a, []) + [b]
       graph[b] = graph.get(b, []) + [a]
   print(dfs(graph, 1))
   ```

3. 단지번호붙이기 https://www.acmicpc.net/problem/2667

   ```
   from queue import Queue
   import sys
   
   n = int(sys.stdin.readline())
   unit = []
   visited = [[0]*n for i in range(n)]
   que = Queue()
   result = []
   unit = [list(map(int,list(input()))) for _ in range(n)]
   # for i in range(n):
   #     unit.append(list(map(int, str(sys.stdin.readline().rstrip()))))
   dx = [-1, 1, 0, 0]
   dy = [0, 0, -1, 1]
   
   for i in range(n):
       for j in range(n):
           if unit[i][j]==1 and visited[i][j]==0:
               que.put([i,j])
               num = 0
               while que.qsize()>0:
                   [a,b] = que.get()
                   if visited[a][b] == 0:
                       visited[a][b] = 1
                       num += 1
                   for k in range(4):
                       x = a + dx[k]
                       y = b + dy[k]
                       if 0<=x<n and 0<=y<n and unit[x][y]==1 and visited[x][y]==0:
                           que.put([x,y])
               result.append(num)
   
   print(len(result))
   result.sort()
   for r in result:
       print(r)
   ```

   

4. 나이트의 이동 https://www.acmicpc.net/problem/7562

   ```
   from collections import deque
   t = int(input())
   while t:
       l = int(input())
       visited = [[0 for _ in range(l)] for _ in range(l)]
       chess = [[0]*l for _ in range(l)]
       a,b = map(int,input().split())
       c,d = map(int,input().split())
       queue = deque()
       queue.append([a,b,0])
       chess[a][b] = 0
       dx = [-1,1,-2,2,-1,1,-2,2]
       dy = [2,2,1,1,-2,-2,-1,-1]
       while queue:
           v,w,q = queue.popleft()
           visited[v][w] = 1
           print("V,W,이전값",v,w,chess[v][w])
           print(chess)
           if v==c and w==d:
               print(q)
               break
           for xi,yi in zip(dx,dy):
               cx = v + xi
               cy = w + yi
               if 0<=cx<l and 0<=cy<l and visited[cx][cy]==0:
                   queue.append([cx,cy,q+1])
                   chess[cx][cy] = chess[v][w] + 1
       # print(max(map(max,chess)))
       t -= 1
   ```

   